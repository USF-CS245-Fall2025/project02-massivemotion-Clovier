[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/J_c8sizy)
# MassiveMotion
CS 245 Project 02

In my Massive Motion project, I implemented different parts which include: custom list data structures - ArrayList, LinkedList, DoublyLinkedList, and DummyHeadLinkedList, a CelestialBody class that models both objects used in the simulation (star and comets), and the main MassiveMotion class that takes care of the animation, rendering, and configuration. I implemented each list type in its own file and it inherits from the same List interface. The CelestialBody class represents each individual objects as I mentioned earlier (star, comets). Each body has their x and y coordinates along with velocityX and velocityY, which is used to update its' position during each frame (this is to simulate its' motion). In the MassiveMotion class, the configuration/property file provides paramaters for different key + values that provide different paramters based off of what it reads. For example, it provides parameters like the window size, timer delay, comet size, velocty, and the chosen list type. Given which list implementation is used for storing the celestial bodies, the star is initialized at the center of the canvas, while new ones are generated based off of a set probability value at each sides of the canvas. 

From each of the list implementations, I believe the ArrayList was the most efficient choice for manging the celestial objects in this simulation project. The main tasks are to get, add, and remove. Yes, while I understand that the add and remove operations have similar time complexities across all list types, and that when you add an item, it's added to the end of the list, and O(n) for removing due to shifting or traversal. However, the get operation is significantly faster in the ArrayList. Getting an element by index in an ArrayList takes O(1) time, whereas LinkedList requires O(n) traversal to reach the same position. Since the simulation is constantly getting bodies by index during each frame update, I thought that using an ArrayList was the most efficient.  

To run the program, you have to navigate to the source directory in the terminal. Then compile using javac MassiveMotion.java, then execute the program by java MassiveMotion MassiveMotion.config
